스프링부트에서 말하는 Mapper는 데이터베이스의 데이터를 애플리케이션의 객체로 변환하거나, 반대로 객체의 데이터를 데이터베이스에 저장할 때 그 역할을 하는 “중개자”라고 볼 수 있습니다.

주요 포인트

데이터 변환 역할:
데이터베이스의 행(Row)과 컬럼(Column)을 자바 객체의 속성(Property)과 매핑하여, SQL 쿼리 결과를 쉽게 다룰 수 있도록 해줍니다.

주로 사용하는 라이브러리:
스프링부트에서는 MyBatis 같은 라이브러리를 활용하여 Mapper 인터페이스를 정의합니다.
예를 들어, 인터페이스에 SQL문(또는 XML 매핑 파일)을 연결하면, 해당 인터페이스의 메서드를 호출할 때 자동으로 SQL 쿼리가 실행되고 결과가 객체로 반환됩니다.

코드 예시 (MyBatis):

@Mapper
public interface UserMapper {
    @Select("SELECT * FROM user WHERE id = #{id}")
    User getUserById(int id);
}

위 예시처럼, @Mapper 어노테이션과 SQL문을 통해 데이터베이스와의 연결을 쉽게 설정할 수 있습니다.

비즈니스 로직 분리:
Mapper를 사용하면 데이터 접근 로직과 비즈니스 로직을 분리할 수 있어, 코드의 유지보수성과 가독성이 향상됩니다.


정리

쉽게 말해, 스프링부트에서 Mapper는 데이터베이스와 자바 객체 사이의 “번역기” 역할을 하여, 개발자가 복잡한 SQL 처리 없이도 데이터를 효율적으로 다룰 수 있도록 도와주는 중요한 컴포넌트입니다.






스프링부트 Maven 프로젝트에서는 여러 핵심 파일과 폴더들이 존재하는데, 각각의 역할은 아래와 같습니다.


---

1. pom.xml

역할:
Maven 프로젝트의 설정 파일로, 프로젝트의 의존성(dependencies), 플러그인(plugin), 빌드 설정 등을 정의합니다.

특징:
프로젝트의 그룹ID, 아티팩트ID, 버전 등을 지정하며, Spring Boot 관련 의존성(예: spring-boot-starter)을 추가해 손쉽게 필요한 라이브러리를 관리할 수 있습니다.



---

2. mvnw (및 mvnw.cmd)

역할:
Maven Wrapper 스크립트입니다.

특징:

mvnw: 리눅스/유닉스/맥OS에서 사용되는 실행 스크립트

mvnw.cmd: 윈도우 환경에서 사용되는 실행 스크립트

이 스크립트들을 사용하면 개발 환경에 Maven이 설치되어 있지 않아도, 프로젝트에 설정된 Maven 버전을 자동으로 다운로드하여 빌드할 수 있습니다.




---

3. target 폴더

역할:
Maven 빌드 작업의 결과물이 생성되는 디렉토리입니다.

특징:

컴파일된 클래스 파일, 패키징된 JAR/WAR 파일 등이 이 폴더에 생성됩니다.

빌드 작업 시 자동으로 생성되며, 일반적으로 버전 관리(Git 등)에서는 제외(.gitignore)하는 것이 좋습니다.




---

4. .mvn 폴더

역할:
Maven Wrapper 관련 설정과 파일들을 담고 있는 폴더입니다.

특징:

Maven Wrapper의 동작에 필요한 JAR 파일 및 설정 파일(wrapper 설정 파일 등)이 위치합니다.

이 폴더 덕분에 프로젝트 구성원이 동일한 Maven 버전으로 빌드를 수행할 수 있습니다.




---

이와 같이, 각 파일과 폴더는 스프링부트 프로젝트의 빌드 및 의존성 관리를 원활하게 하기 위해 중요한 역할을 담당하고 있습니다.








스프링부트(또는 일반적인 Maven 기반 자바 웹 프로젝트)에서 src/main 폴더 아래에는 주로 세 가지 폴더가 존재하며, 각각의 역할은 다음과 같습니다.


---

1. java 폴더

역할:
프로젝트의 실제 자바 소스 코드가 위치하는 곳입니다.

설명:

애플리케이션의 메인 클래스, 컨트롤러, 서비스, 도메인 클래스 등 모든 자바 코드 파일들이 이곳에 저장됩니다.

패키지 구조에 따라 코드가 정리되며, 컴파일 후 클래스 파일들이 생성됩니다.




---

2. resources 폴더

역할:
애플리케이션의 설정 파일, 프로퍼티, XML, 템플릿, 정적 리소스 등 자바 코드 외의 여러 리소스 파일들을 담습니다.

설명:

application.properties / application.yml: 스프링부트의 환경 설정 파일

메시지 파일: 다국어 지원을 위한 리소스 번들

정적 파일: 스프링부트에서는 주로 static 또는 public 폴더를 resources 내부에 만들어 CSS, JS, 이미지 파일을 관리합니다.

템플릿 파일: Thymeleaf, FreeMarker 등 뷰 템플릿 파일들을 위한 templates 폴더도 이곳에 위치합니다.




---

3. webapp 폴더

역할:
전통적인 자바 웹 애플리케이션에서 사용하는 웹 관련 파일들을 저장하는 곳입니다.

설명:

JSP 파일 등: 서블릿 컨테이너 기반으로 동작하는 웹 애플리케이션에서는 JSP, HTML 파일 등을 이곳에 배치합니다.

정적 리소스: 경우에 따라 CSS, JS, 이미지 파일을 함께 두기도 합니다.

스프링부트 프로젝트에서는:

스프링부트가 내장 톰캣(또는 Jetty 등)을 사용하기 때문에, 보통 정적 리소스는 resources/static 또는 resources/public 폴더에 두는 것이 일반적입니다.

단, 전통적인 WAR 파일 배포 방식이나 JSP 사용 시에는 여전히 webapp 폴더를 사용하게 됩니다.





---

이처럼 각 폴더는 개발하는 애플리케이션의 성격에 맞게 코드와 리소스를 체계적으로 분리하여 관리할 수 있도록 도와줍니다.






프로젝트마다 다소 차이가 있을 수 있지만, 일반적으로 각 패키지는 역할별로 클래스를 모듈화하여 관리하기 위해 구분됩니다. 아래는 각 폴더의 일반적인 역할에 대한 설명입니다.

common
애플리케이션 전반에서 공통적으로 사용되는 유틸리티 클래스, 상수, 공통 로직 등을 모아둡니다. 예를 들어 문자열 처리, 날짜 계산, 공통 예외 처리 등이 여기에 포함될 수 있습니다.

config
스프링이나 기타 라이브러리의 설정 및 초기화 관련 클래스를 배치합니다.

스프링 빈(Bean) 설정

데이터베이스 연결, 프로퍼티 로딩 등 환경 설정

보안, CORS, 메시지 컨버터 등의 추가 설정을 포함할 수 있습니다.


controller_service
일반적으로 웹 요청을 처리하는 컨트롤러와 비즈니스 로직을 담당하는 서비스 클래스를 모아둡니다.

Controller: 클라이언트의 HTTP 요청을 받고, 적절한 서비스를 호출하여 결과를 반환하는 역할

Service: 실제 비즈니스 로직을 처리하여 컨트롤러와 DAO, 혹은 기타 레이어 사이의 중간 다리 역할
(보통은 별도의 패키지로 나누기도 하지만, 이 프로젝트에서는 한 곳에 모아둔 것으로 보입니다.)


dao
Data Access Object의 약자로, 데이터베이스와의 직접적인 상호작용(SQL 실행, ORM 사용 등)을 담당합니다.

DB CRUD 작업을 수행하는 클래스나 인터페이스가 위치합니다.


dto
Data Transfer Object로, 레이어 간 데이터 전달을 위한 단순 객체들을 정의합니다.

주로 클라이언트와 서버 간, 혹은 서비스와 컨트롤러 간에 필요한 데이터 구조를 명시하는 역할을 합니다.


login
사용자 인증 및 로그인 관련 기능을 담당하는 클래스들을 모아둡니다.

로그인 컨트롤러, 로그인 서비스, 인증 관련 모델 등이 여기에 포함될 수 있습니다.


main
애플리케이션의 시작점(예, main() 메서드가 포함된 클래스)을 비롯해 전체 애플리케이션의 핵심 역할을 하는 클래스를 둘 수 있습니다.

스프링부트 애플리케이션의 부트스트랩 역할을 하는 클래스가 대표적입니다.


scheduler
주기적으로 실행되어야 하는 작업(예: 배치 처리, 크론 작업 등)을 담당하는 클래스들을 배치합니다.

스프링의 @Scheduled 애노테이션이 적용된 메서드들이 여기에 위치할 수 있습니다.


secutity
이름이 오타일 가능성이 있지만, 일반적으로 security라면 보안 관련 설정 및 기능(인증, 권한 관리, 필터 등)을 담당하는 클래스를 모아둡니다.

test_index
테스트나 데모용으로 사용되는 인덱스 페이지 또는 임시로 만든 클래스들이 위치할 가능성이 있습니다.

애플리케이션이 잘 동작하는지 확인하기 위한 기본 페이지나 간단한 테스트 로직을 포함할 수 있습니다.



각 패키지는 해당 역할에 맞는 클래스를 모아두어 코드의 유지보수성과 가독성을 높이고, 기능별 책임 분리를 통해 개발 효율을 높이기 위한 구조입니다.





스프링부트 애플리케이션은 특정 폴더나 패키지 순서에 맞춰서 실행되는 것이 아니라, Spring Framework의 컨테이너(애플리케이션 컨텍스트)가 초기화되는 과정에서 각 컴포넌트들이 자동으로 스캔되고 등록되며, 필요한 시점에 호출됩니다. 다만, 각 역할별로 대략적인 실행(초기화 및 호출) 흐름을 이해하면 도움이 됩니다.


---

1. 애플리케이션 부트스트랩 (main 패키지)

시작점:
main 패키지에 있는 main() 메서드가 애플리케이션의 시작점입니다.
이 메서드에서 SpringApplication.run()을 호출하면 스프링 부트가 애플리케이션 컨텍스트를 초기화하고 내장 톰캣(또는 다른 웹 서버)을 실행합니다.



---

2. 설정 및 빈 초기화 (config, common, secutity 등)

config 패키지:
애플리케이션 전반의 설정(예, 데이터소스, 트랜잭션, CORS, 스케줄러, 보안 등)을 정의한 클래스들이 초기화됩니다.
이때, 스프링의 자동설정(auto-configuration)과 함께 외부 설정 파일(application.properties나 application.yml)도 반영됩니다.

secutity (security) 패키지:
보안 관련 설정(인증, 인가, 필터 등)이 적용되어, 사용자의 접근 제어나 보안 정책이 초기화됩니다.

common 패키지:
특별히 초기화 순서를 갖는 건 아니지만, 공통 유틸리티나 상수들은 다른 컴포넌트에서 필요할 때 호출됩니다.



---

3. 컴포넌트 스캔 및 빈 등록 (controller_service, dao, dto, login 등)

controller_service 패키지:

Controller: 웹 요청을 처리할 컨트롤러들이 스캔되어 등록되고, 내장 DispatcherServlet에 의해 HTTP 요청이 들어올 때 호출됩니다.

Service: 컨트롤러에서 호출하는 비즈니스 로직을 수행하며, DAO와 연계하여 실제 데이터 처리 작업을 진행합니다.


dao 패키지:
데이터베이스와의 CRUD 작업을 담당하는 DAO 클래스나 인터페이스들이 스캔되어, 서비스 계층에서 호출할 수 있도록 빈으로 등록됩니다.

dto 패키지:
데이터 전달 객체들은 별도의 초기화 과정 없이, 컨트롤러와 서비스 혹은 DAO 간에 데이터 구조를 정의하는 역할로 사용됩니다.

login 패키지:
로그인과 인증 관련 컴포넌트들이 초기화되며, 사용자가 로그인 요청을 할 때 호출됩니다.



---

4. 기타 기능 (scheduler, test_index 등)

scheduler 패키지:

스프링의 @Scheduled 애노테이션이 붙은 메서드들이 등록되어, 애플리케이션 시작 후 백그라운드에서 주기적으로 실행됩니다.


test_index 패키지:

애플리케이션의 테스트용 또는 임시 인덱스 페이지, 데모용 기능들이 포함되어 있을 가능성이 있습니다.

이는 실제 서비스 로직과는 별개로 초기 개발 또는 디버깅 시 호출될 수 있습니다.




---

실행 흐름 요약

1. 부트스트랩:
main() 메서드 호출 → 스프링 부트가 애플리케이션 컨텍스트를 생성 및 초기화.


2. 설정 및 빈 등록:
config, secutity, 그리고 auto-configuration을 통해 각종 설정이 적용되고, 컴포넌트 스캔을 통해 controller, service, dao 등 필요한 빈들이 등록됨.


3. 내장 서버 실행:
내장 톰캣(또는 다른 웹 서버)이 시작되어 HTTP 요청을 기다림.


4. 요청 처리 및 기능 실행:

HTTP 요청이 들어오면 controller_service 패키지의 컨트롤러가 요청을 받아 서비스와 DAO를 통해 처리.

로그인, 보안, 스케줄러 작업 등은 각각의 트리거(사용자 요청, 스케줄 주기 등)에 따라 호출됨.



5. 공통 기능 호출:
필요한 시점에 common 유틸리티나 상수 등이 사용됨.


6. 테스트 및 임시 기능:
test_index에 위치한 클래스나 페이지는 주로 테스트나 개발 중 임시 확인용으로 사용될 수 있음.




---

결론

실행 순서는 엄격하게 "폴더 순서"대로 이루어지는 것이 아니라, 스프링의 IoC 컨테이너가 애플리케이션을 부트스트랩하면서 설정 파일, 빈 등록, 컴포넌트 스캔을 통해 각 컴포넌트를 필요 시점에 초기화하고 호출하는 구조입니다. 따라서 개발자가 코드를 작성할 때는 각 패키지의 역할을 명확하게 구분해두어, 스프링이 알아서 올바른 순서로 초기화 및 실행할 수 있도록 하는 것이 핵심입니다.









아래는 스프링부트 애플리케이션의 실행 과정을 아주 간단하게 정리한 것입니다.

1. main 폴더

main() 메서드가 애플리케이션 시작점입니다.

SpringApplication.run()을 호출하여 스프링 컨테이너를 생성합니다.



2. config, secutity, common 폴더

애플리케이션의 환경설정과 보안, 공통 기능을 초기화합니다.



3. controller_service, dao, dto, login 폴더

Controller: HTTP 요청을 받아 처리합니다.

Service: 비즈니스 로직을 실행합니다.

DAO: 데이터베이스와 통신합니다.

DTO: 데이터 전달 역할을 합니다.

Login: 사용자 인증 및 로그인 기능을 담당합니다.



4. scheduler 폴더

정해진 시간마다 실행되는 작업(예: 배치, 스케줄러)이 시작됩니다.



5. test_index 폴더

테스트나 간단한 데모용 기능을 위한 코드가 포함될 수 있습니다.




즉, main에서 시작하여 설정/보안이 먼저 초기화되고, 이후 **웹 요청 처리(Controller → Service → DAO)**와 스케줄러 작업이 실행되는 구조입니다.





각 폴더는 다음과 같은 역할을 합니다.

mapper 폴더:
MyBatis와 같은 라이브러리를 사용할 때, SQL 쿼리와 자바 객체 간 매핑을 정의한 XML 파일들을 저장합니다.

static 폴더:
웹 페이지에서 사용하는 정적 리소스(CSS, JavaScript, 이미지 등)를 보관합니다.
스프링부트는 이 폴더 내의 파일들을 별도의 처리 없이 그대로 제공해줍니다.

templates 폴더:
Thymeleaf, FreeMarker 등 템플릿 엔진을 사용할 경우, 동적인 HTML 페이지(뷰 템플릿)를 저장합니다.
클라이언트에게 보여질 최종 웹 페이지를 생성할 때 사용됩니다.







다음은 위 프로젝트 구조에 대한 간단하고 심플한 퐁 정리서(요약 문서)입니다.


---

1. 프로젝트 개요

타입: Spring Boot 기반 Maven 프로젝트

주요 관리 도구: Maven (pom.xml, mvnw, .mvn 폴더)

빌드 산출물: target 폴더 (컴파일된 클래스, JAR/WAR 파일)



---

2. src/main 폴더 구성

2-1. java 폴더

애플리케이션의 자바 소스 코드가 위치하며, 각 역할별 패키지로 구성됨

main:

애플리케이션 시작점 (main() 메서드 포함)

SpringApplication.run()을 호출하여 전체 실행을 시작


config:

스프링 및 기타 라이브러리의 설정 클래스들

데이터베이스, 트랜잭션, CORS 등 환경 설정


secutity:

보안 관련 설정(인증, 인가, 필터 등)

패키지명이 오타일 수 있으나, 기본 역할은 보안 처리


controller_service:

Controller: 클라이언트의 HTTP 요청을 받아 처리

Service: 비즈니스 로직 수행 및 DAO와 연계


dao:

데이터베이스 접근 및 CRUD 작업을 수행하는 객체


dto:

계층 간 데이터 전달을 위한 단순 객체(Data Transfer Object)


common:

프로젝트 전반에서 사용되는 유틸리티, 상수, 공통 로직


login:

사용자 인증 및 로그인 관련 기능 담당


scheduler:

정해진 주기마다 실행되는 작업(배치, 예약 작업)을 관리


test_index:

테스트용 혹은 데모용 페이지/코드가 위치 (개발 중 기능 검증 목적)




---

2-2. resources 폴더

애플리케이션에서 사용하는 다양한 리소스 파일이 위치

mapper:

MyBatis 등 SQL 매핑 파일(XML)들을 저장

데이터베이스 쿼리와 자바 객체 간 매핑 정보 관리


static:

CSS, JavaScript, 이미지 등 웹 정적 리소스 보관

스프링부트가 별도 처리 없이 클라이언트에 제공


templates:

Thymeleaf, FreeMarker 등의 템플릿 파일

동적 HTML 페이지(뷰)를 생성하는 데 사용




---

2-3. webapp 폴더

전통적인 웹 애플리케이션에서 사용하는 웹 관련 파일들(JSP, HTML 등)을 배치

스프링부트에서는 보통 resources/static, templates를 활용하지만, WAR 패키징 시 webapp을 사용할 수도 있음



---

3. 애플리케이션 실행 흐름

1. 부트스트랩 (main 폴더):

main() 메서드 실행 → SpringApplication.run() 호출

스프링부트가 애플리케이션 컨텍스트(빈 등록, 자동 설정 등)를 초기화



2. 설정 및 빈 초기화 (config, secutity, common):

환경 설정, 보안, 공통 기능들이 초기화되어 전체 애플리케이션에 적용



3. 컴포넌트 스캔 및 빈 등록 (controller_service, dao, dto, login):

HTTP 요청을 처리할 컨트롤러와 서비스, 데이터베이스 작업을 위한 DAO가 등록

클라이언트 요청에 따라 적절한 빈이 호출되어 기능 수행



4. 정적 및 동적 리소스 제공 (resources):

클라이언트 요청 시, 정적 리소스는 static 폴더에서, 동적 페이지는 templates 폴더에서 제공



5. 예약 작업 (scheduler):

설정된 스케줄에 따라 주기적으로 백그라운드 작업 실행



6. 테스트/데모 (test_index):

개발 중 간단한 기능 확인이나 데모용 페이지로 활용





---

이 정리서는 프로젝트의 전반적인 구조와 실행 흐름을 한눈에 파악할 수 있도록 돕습니다. 각 패키지와 폴더는 역할에 따라 분리되어 관리되며, 스프링부트의 자동 설정과 컴포넌트 스캔을 통해 필요한 시점에 초기화되고 호출됩니다.





아래는 위 프로젝트의 간단 요약본입니다.


---

1. 프로젝트 기본 구성

Maven 기반 Spring Boot 프로젝트

pom.xml: 프로젝트 의존성 및 설정 관리

mvnw / mvnw.cmd: Maven Wrapper 스크립트 (Maven 미설치 시에도 빌드 가능)

target: 빌드 산출물 (컴파일된 클래스, JAR/WAR 파일)

.mvn: Maven Wrapper 관련 설정 파일




---

2. src/main 폴더 구조

2-1. java 폴더 (자바 코드)

main: 애플리케이션 시작점 (main() 메서드 및 SpringApplication.run 호출)

config: 환경 설정 (데이터소스, 트랜잭션, CORS 등)

secutity: 보안 관련 설정 (인증, 권한 등)

controller_service:

Controller: 클라이언트의 HTTP 요청 처리

Service: 비즈니스 로직 수행


dao: 데이터베이스 접근 (CRUD 작업)

dto: 데이터 전달 객체 (계층 간 데이터 이동)

common: 공통 유틸리티, 상수, 공통 로직

login: 로그인 및 인증 기능

scheduler: 주기적으로 실행되는 작업 (배치, 예약 작업)

test_index: 테스트 또는 데모용 코드


2-2. resources 폴더 (리소스 파일)

mapper: MyBatis SQL 매핑 XML 파일

static: 정적 리소스 (CSS, JS, 이미지)

templates: 템플릿 파일 (Thymeleaf 등으로 동적 HTML 생성)


2-3. webapp 폴더

전통적인 웹 애플리케이션의 웹 파일(JSP, HTML 등)을 위한 폴더

스프링부트에서는 주로 resources의 static/ templates를 사용하지만, WAR 배포 시 활용 가능




---

3. 애플리케이션 실행 흐름

1. 부트스트랩:

main() 메서드 실행 → SpringApplication.run()으로 스프링 컨테이너 초기화



2. 설정 & 빈 등록:

config, secutity, common 패키지에서 설정 적용 및 컴포넌트 스캔을 통해 필요한 빈(Controller, Service, DAO 등) 등록



3. 웹 요청 처리:

HTTP 요청이 들어오면 controller_service의 컨트롤러가 요청을 받고, 서비스와 DAO를 통해 처리



4. 정적/동적 리소스 제공:

클라이언트 요청 시, static 폴더의 정적 파일 또는 templates 폴더의 동적 HTML이 제공됨



5. 기타 기능:

scheduler: 예약 작업 실행

test_index: 개발/테스트용 코드 실행





---

이 요약본은 프로젝트의 핵심 구조와 실행 흐름을 한눈에 파악할 수 있도록 간단하게 정리한 문서입니다.







아래는 위 프로젝트의 전반적인 구조와 실행 과정을 한눈에 파악할 수 있도록 정리한 총 정리서입니다.


---

총 정리서

1. 프로젝트 개요

프로젝트 유형:
Spring Boot 기반 Maven 프로젝트

주요 특징:

Maven을 이용한 의존성 관리 및 빌드 (pom.xml, mvnw, .mvn, target)

Spring Boot의 자동 설정과 내장 톰캣을 활용한 실행




---

2. 주요 파일 및 폴더 구조

2-1. Maven 관련 파일/폴더

pom.xml:

프로젝트 의존성, 플러그인, 빌드 설정 등을 정의


mvnw / mvnw.cmd:

Maven Wrapper 스크립트

Maven 미설치 환경에서도 지정된 버전의 Maven으로 빌드 가능


.mvn 폴더:

Maven Wrapper 관련 설정 파일 및 JAR이 위치


target 폴더:

빌드 산출물(컴파일된 클래스, JAR/WAR 파일 등)이 생성되는 디렉토리



2-2. src/main 폴더

java 폴더:

애플리케이션의 모든 자바 소스 코드와 각 역할별 패키지들이 포함


resources 폴더:

애플리케이션 설정 파일, SQL 매핑 파일, 정적/동적 리소스들이 위치


webapp 폴더:

전통적인 웹 애플리케이션의 JSP, HTML 등 웹 관련 파일들을 저장

스프링부트에서는 주로 resources의 static, templates를 활용




---

3. src/main/java 폴더 세부 구조

main:

애플리케이션의 시작점 (main() 메서드 포함)

SpringApplication.run()을 호출해 스프링 컨테이너를 초기화


config:

데이터소스, 트랜잭션, CORS 등 애플리케이션 환경 설정 클래스들이 위치


secutity:

(패키지명이 오타일 수 있음)

사용자 인증, 권한 관리 등 보안 관련 설정 및 필터 구현


controller_service:

Controller: 클라이언트의 HTTP 요청을 받아 처리

Service: 비즈니스 로직 실행 및 데이터 처리를 위해 DAO와 연계


dao:

데이터베이스와 직접 상호작용하여 CRUD 작업 수행


dto:

레이어 간 데이터 전달을 위한 단순 객체(Data Transfer Object) 정의


common:

공통 유틸리티, 상수, 공통 로직 등을 모아둔 패키지


login:

로그인 및 사용자 인증과 관련된 기능 구현


scheduler:

@Scheduled 애노테이션 등을 활용해 주기적으로 실행되는 작업(배치, 예약 작업) 구현


test_index:

테스트 또는 데모용 코드가 포함되어, 개발 중 기능 검증에 활용




---

4. src/main/resources 폴더 세부 구조

mapper:

MyBatis 등 SQL 매핑 파일(XML)이 위치

자바 객체와 SQL 쿼리 간 매핑 정보를 관리


static:

CSS, JavaScript, 이미지 등 정적 리소스 파일들이 저장

클라이언트 요청 시 별도 처리 없이 그대로 제공됨


templates:

Thymeleaf, FreeMarker 등 템플릿 엔진을 이용한 동적 HTML 파일들이 위치

서버에서 데이터를 바인딩해 최종 웹 페이지를 생성




---

5. 애플리케이션 실행 흐름

1. 부트스트랩 (main 폴더):

main() 메서드 실행 → SpringApplication.run() 호출

스프링 컨테이너와 내장 웹 서버(톰캣) 초기화



2. 환경 설정 및 빈 등록 (config, secutity, common):

설정 클래스에서 환경, 보안, 공통 로직 등이 초기화되고 컴포넌트 스캔을 통해 빈으로 등록됨



3. 웹 요청 처리 (controller_service, dao, dto, login):

HTTP 요청이 들어오면 Controller가 요청을 받아 Service를 호출

Service는 DAO를 통해 데이터베이스 작업을 수행하며, DTO를 사용해 데이터 전달



4. 리소스 제공 (resources):

정적 리소스는 static 폴더에서, 동적 웹 페이지는 templates 폴더에서 제공



5. 예약 작업 (scheduler):

주기적으로 실행되는 배치 작업 또는 예약 작업이 백그라운드에서 동작



6. 테스트/데모 (test_index):

개발 중 임시 기능 확인이나 데모용 코드로 활용





---

6. 결론

구조적 장점:
역할별 패키지 분리로 코드 유지보수와 확장성이 높음
Maven과 Spring Boot의 자동 설정으로 빌드 및 실행이 간편

실행 과정:
메인 진입점에서부터 환경 설정, 컴포넌트 스캔, 웹 요청 처리, 정적/동적 리소스 제공, 그리고 예약 작업까지 일련의 과정이 자동으로 순차 실행됨



---

이 총 정리서는 프로젝트의 전체적인 구조와 실행 흐름을 간단하고 명료하게 파악할 수 있도록 작성되었습니다.






프로젝트 루트 폴더를 확인해보면 됩니다.

Maven 프로젝트:

보통 pom.xml 파일이 존재합니다.


Gradle 프로젝트:

보통 build.gradle 또는 settings.gradle 파일이 존재합니다.



현재 Gradle 관련 파일이 보이지 않는다면, 아마도 Maven 프로젝트일 가능성이 높습니다.

